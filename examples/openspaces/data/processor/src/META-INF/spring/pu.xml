<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:os-core="http://www.openspaces.org/schema/core"
       xmlns:os-events="http://www.openspaces.org/schema/events"
       xmlns:os-remoting="http://www.openspaces.org/schema/remoting"
       xmlns:os-sla="http://www.openspaces.org/schema/sla"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.openspaces.org/schema/core http://www.openspaces.org/schema/core/openspaces-core.xsd
       http://www.openspaces.org/schema/events http://www.openspaces.org/schema/events/openspaces-events.xsd
       http://www.openspaces.org/schema/remoting http://www.openspaces.org/schema/remoting/openspaces-remoting.xsd
       http://www.openspaces.org/schema/sla http://www.openspaces.org/schema/sla/openspaces-sla.xsd">

    <!--
        The SLA bean used when deploying this processing unit to the Service Grid.

        The SLA uses a partitioned schema with primary and backup. It will create 2
        partitions each with a single backup.

        The SLA bean also mandates that a primary and a backup won't run under the same
        GSC by setting the maxInstancesPerVM to 1.

        Within the SLA several Monitors can be defined which can then be viewed within the UI.
        This monitors (on top of the built in monitors such as CPU and Memory) can be used
        with a policy handler (not shown here).
    -->
    <os-sla:sla cluster-schema="partitioned-sync2backup" number-of-instances="2" number-of-backups="1"
                max-instances-per-vm="1">
        <os-sla:monitors>
            <os-sla:bean-property-monitor name="Processed Data"
                                          bean-ref="dataProcessedCounter" property-name="processedDataCount"/>
        </os-sla:monitors>
    </os-sla:sla>

    <!--
        Spring propery configurer which allows us to use system properties (such as user.name).
    -->
    <bean id="propertiesConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"/>

    <!--
        Enables the usage of @GigaSpaceContext annotation based injection.
    -->
    <os-core:giga-space-context/>

    <!--
        A bean representing a space (an IJSpace implementation).

        Note, we do not specify here the cluster topology of the space. It is declated outside of
        the processing unit or within the SLA bean.
    -->
    <os-core:space id="space" url="/./space"/>

    <!--
        OpenSpaces simplified space API built on top of IJSpace/JavaSpace.
    -->
    <os-core:giga-space id="gigaSpace" space="space"/>

    <!--
        Defines a local Jini transaction manager.
    -->
    <os-core:local-tx-manager id="transactionManager" giga-space="gigaSpace"/>

    <!--
        The data processor bean
    -->
    <bean id="dataProcessor" class="org.openspaces.example.data.processor.DataProcessor"/>

    <!--
        A polling event container that perfoms (by default) polling take operations against
        the space using the provided template (in our case, and the non processed data objects).
        Once a match is found, the data processor bean event listener is triggered using the
        annotation adapter.
    -->
    <os-events:polling-container id="dataProcessorPollingEventContainer" giga-space="gigaSpace">
        <os-events:tx-support tx-manager="transactionManager"/>
        <os-core:template>
            <bean class="org.openspaces.example.data.common.Data">
                <property name="processed" value="false"/>
            </bean>
        </os-core:template>
        <os-events:listener>
            <os-events:annotation-adapter>
                <os-events:delegate ref="dataProcessor"/>
            </os-events:annotation-adapter>
        </os-events:listener>
    </os-events:polling-container>

    <bean id="dataProcessedCounter" class="org.openspaces.example.data.processor.DataProcessedCounter"/>

    <!--
        A notified event container counting all the processed data objects using notifications basde on
        an sql template.
    -->
    <os-events:notify-container id="dataProcessedCounterNotifyContainer" giga-space="gigaSpace" com-type="UNICAST"
            perform-take-on-notify="false" ignore-event-on-null-take="true">
        <os-events:notify write="true" update="true"/>
        <os-events:batch size="10" time="5000"/>
        <os-core:sql-query where="processed = true" class="org.openspaces.example.data.common.Data"/>
        <os-events:listener>
            <os-events:annotation-adapter>
                <os-events:delegate ref="dataProcessedCounter"/>
            </os-events:annotation-adapter>
        </os-events:listener>
    </os-events:notify-container>


    <!--
        A context loader loading a Spring applicaiton context defined by the location only when
        this processing unit instance is primary (in a primary backup scenario).
    -->
    <os-core:context-loader id="modeExample" location="classpath:/META-INF/spring/mode/mode.xml"/>

    <!--
        Remoting supprt exporting the data processor for remoting invocation using OpenSpaces Remoting.

        Note, remoting is based on the different event containers and provides an event listner that
        exports a list of services for remote invocations. In our case, the data processor is exposed.

        Also note, using notifications instead of polling takes is just a matter of configuraion. Changing
        to notify container means just changing the xml element name, and setting two attributes to true:
        perform-take-on-notify and ignore-event-on-null-take.
    -->
    <os-events:polling-container id="remotingContainer" giga-space="gigaSpace" concurrent-consumers="2">
        <os-events:listener>
            <os-remoting:service-exporter>
                <os-remoting:service ref="dataProcessor"/>
            </os-remoting:service-exporter>
        </os-events:listener>
    </os-events:polling-container>
</beans>